#ifndef _n6Vert_h_
#define _n6Vert_h_


// Header generated from binary by WriteAsBinHeader()..
static const int n6VertLength = 278;
static const unsigned int n6Vert[n6VertLength]={
	0x20205356,	0xFFFF0008,	0x00000048,	0x01020000,	0x0000000E,	0x00000018,	0x00000000,	0x00000000,	0x00000005,	0x00000004,
	0x00000003,	0x00000000,	0x00000000,	0x00000000,	0x00000001,	0x00000000,	0x000000A2,	0x00000000,	0x00000000,	0x02030000,
	0x237820E4,	0x00000000,	0x00E40100,	0x02045500,	0x2EF820E4,	0x00000000,	0x00E40100,	0x0205AA00,	0x2EF820E4,	0x00000000,
	0x00E40100,	0x0206FF00,	0x0EF800E4,	0x00000000,	0x03000000,	0x020E0000,	0x237820E4,	0x00000000,	0x03E40100,	0x020F5500,
	0x2EF820E4,	0x00000000,	0x03E40100,	0x0210AA00,	0x2EF820E4,	0x00000000,	0x03E40100,	0x0211FF00,	0x0EF802E4,	0x00000000,
	0x04000000,	0x02120000,	0x237820E4,	0x00000000,	0x04E40100,	0x02135500,	0x2EF820E4,	0x00000000,	0x04E40100,	0x0214AA00,
	0x2EF820E4,	0x00000000,	0x04E40100,	0x0215FF00,	0x0EF803E4,	0x00000000,	0x00000000,	0x00020000,	0x00FA01E4,	0x00000000,
	0x00000000,	0x00000000,	0x1E000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x3F800000,	0x3F800000,
	0x3F800000,	0x3F800000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,
	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,
	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,
	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,
	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,
	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,
	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,
	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,
	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x3F800000,	0x00000000,	0x00000000,	0x00000000,
	0x00000043,	0x00000006,	0x00000009,	0x00000000,	0x00000000,	0x0000004A,	0x00000005,	0x00000009,	0x00000000,	0x00000008,
	0x0000005B,	0x00000006,	0x00000006,	0x00000000,	0x00000004,	0x00000070,	0x0000000E,	0x00000009,	0x00000000,	0x0000000C,
	0x00000089,	0x0000000E,	0x00000009,	0x00000000,	0x00000010,	0x00000000,	0x0000000B,	0x00000009,	0x00010004,	0x00000000,
	0x00000050,	0x0000000A,	0x00000009,	0x00010004,	0x00000004,	0x0000007F,	0x00000009,	0x00000009,	0x00010004,	0x00000008,
	0x00000098,	0x00000009,	0x00000009,	0x00010004,	0x0000000C,	0x0000000C,	0x00000019,	0x0000000E,	0x00020001,	0x0000000C,
	0x00000026,	0x0000000F,	0x0000000E,	0x00020001,	0x0000001C,	0x00000036,	0x0000000C,	0x0000000D,	0x00020001,	0x0000002C,
	0x00000062,	0x0000000D,	0x0000000E,	0x00020001,	0x00000038,	0x00000002,	0x00000010,	0x505F6C67,	0x7469736F,	0x006E6F69,
	0x65646F4D,	0x6569566C,	0x6F725077,	0x7463656A,	0x4D6E6F69,	0x69727461,	0x6F4D0078,	0x566C6564,	0x4D776569,	0x69727461,
	0x6F4E0078,	0x6C616D72,	0x7274614D,	0x56007869,	0x65747265,	0x6F430078,	0x00726F6C,	0x6E6F7246,	0x6C6F4374,	0x4E00726F,
	0x616D726F,	0x6554006C,	0x72757478,	0x74614D65,	0x00786972,	0x746C754D,	0x78655469,	0x726F6F43,	0x54003064,	0x6F437865,
	0x3064726F,	0x6C754D00,	0x65546974,	0x6F6F4378,	0x00316472,	0x43786554,	0x64726F6F,	0x00000031,};

//checksum generated by simpleCheckSum()
static const unsigned int n6VertCheckSum = 52;

static const char* n6VertText = 
	"#define _isMipmap1             1 \n"
	"#define _isMipmap0             1 \n"
	"#define _fogMode               0 \n"
	"#define _texMode1              3 \n"
	"#define _texMode0              1 \n"
	"#define _pointSprite1          0 \n"
	"#define _pointSprite0          0 \n"
	"#define _matrixPaletteEnable   0 \n"
	"#define _userClip              0 \n"
	"#define _lightEnabled          0 \n"
	"#define _pointEnabled          0 \n"
	"\n"
	"\n"
	"\n"
	"uniform mat4 ModelViewProjectionMatrix ; \n"
	"\n"
	"//#if((_lightEnabled != 0) || (_fogMode != 0) || (_pointEnabled != 0)) \n"
	"uniform mat4 ModelViewMatrix; \n"
	"//#endif \n"
	"\n"
	"uniform mat3 NormalMatrix; \n"
	"\n"
	"\n"
	"\n"
	"attribute vec4 Vertex; \n"
	"attribute vec4 Color; \n"
	"\n"
	"//For matrix palette we support 4 vertex unit and 10 palette matrix,  \n"
	"//we store the Weights and MatrixIndices for 4 units in \\ xyzw\\  channel. \n"
	"#if (_matrixPaletteEnable == 1) \n"
	"\n"
	"#define MAX_PALETTE_MATRIX 10 \n"
	"#define MAX_VERTEX_UNIT 4 \n"
	"\n"
	"uniform float noOfVertexUnit; \n"
	"uniform mat4 paletteMatrices[MAX_PALETTE_MATRIX]; \n"
	"uniform mat3 paletteNormalMatrices[MAX_PALETTE_MATRIX]; \n"
	"attribute vec4 Weights; \n"
	"attribute vec4 MatrixIndices; \n"
	"#endif \n"
	"\n"
	"varying vec4 FrontColor; \n"
	"\n"
	"// User defined clip plane \n"
	"#if (_userClip == 1) \n"
	"const int MaxClipPlanes = 6; \n"
	"uniform vec4 ClipPlane[MaxClipPlanes]; \n"
	"uniform bool ClipPlaneEnabled[MaxClipPlanes]; \n"
	"varying float PlanePointDOT[MaxClipPlanes]; \n"
	"#endif \n"
	"\n"
	"\n"
	"//============================= \n"
	"// point \n"
	"#if _pointEnabled \n"
	"\n"
	"attribute float PointSize; \n"
	"\n"
	"struct PointParameters \n"
	"{ \n"
	"    float size; \n"
	"    float sizeMin; \n"
	"    float sizeMax; \n"
	"    float fadeThresholdSize; \n"
	"    float distanceConstantAttenuation; \n"
	"    float distanceLinearAttenuation; \n"
	"    float distanceQuadraticAttenuation; \n"
	"}; \n"
	"\n"
	"uniform PointParameters Point; \n"
	"uniform bool PointEnabled; \n"
	"\n"
	"//varying float DerivedPointSize;  \n"
	"float DerivedPointSize;              //  not used in fragment shader varying originally \n"
	"#endif \n"
	"\n"
	"//============================= \n"
	"// fog \n"
	"#if ((_fogMode == 2) ||(_fogMode == 3)) \n"
	"varying float FogFragCoord; \n"
	"//uniform bool FogEnabled; \n"
	"#endif \n"
	"\n"
	"\n"
	"#if (_fogMode == 1) \n"
	"\n"
	"#define LOG2E 1.442695  \n"
	"struct FogParameters \n"
	"{ \n"
	"    float density; \n"
	"    float start; \n"
	"    float end; \n"
	"    vec4 color; \n"
	"    float scale; // Derived: 1.0 / (end - start) \n"
	"    int mode; \n"
	"}; \n"
	"\n"
	"uniform FogParameters Fog; \n"
	"uniform bool FogEnabled; \n"
	"\n"
	"varying float fogLinear; \n"
	"#endif     \n"
	"\n"
	"\n"
	"// \n"
	"//============================= \n"
	"// lighting \n"
	"attribute vec3    Normal; \n"
	"\n"
	"\n"
	"#if  _lightEnabled   \n"
	"const int MaxLights = 8; \n"
	"\n"
	"struct MaterialParameters \n"
	"{ \n"
	"    vec4 emission; \n"
	"    vec4 ambient; \n"
	"    vec4 diffuse; \n"
	"    vec4 specular; \n"
	"    float shininess; \n"
	"}; \n"
	"\n"
	"uniform MaterialParameters FrontNBackMaterial; \n"
	"uniform bool colorMaterialEnabled; \n"
	"// currentMaterial global variable is used for copying FrontNBackMaterial because incase color material is enabled then  \n"
	"// we have to modify the material ambient and diffuse properties with current color which is not possible for uniforms \n"
	"MaterialParameters currentMaterial;  \n"
	"\n"
	"struct LightSourceParameters \n"
	"{ \n"
	"    vec4 ambient; \n"
	"    vec4 diffuse; \n"
	"    vec4 specular; \n"
	"    vec4 position; \n"
	"    vec4 halfVector; \n"
	"    vec3 spotDirection; \n"
	"    float spotExponent; \n"
	"    float spotCutoff; // (range: [0.0, 90.0], 180.0) \n"
	"    float spotCosCutoff; // cos(spotCutoff) (range: [1.0, 0.0], -1.0) \n"
	"    float constantAttenuation; \n"
	"    float linearAttenuation; \n"
	"    float quadraticAttenuation; \n"
	"    bool isDirectional; \n"
	"}; \n"
	"\n"
	"uniform LightSourceParameters LightSource[MaxLights]; \n"
	"\n"
	"struct LightModelParameters \n"
	"{ \n"
	"    vec4 ambient; \n"
	"    bool isTwoSided; \n"
	"}; \n"
	"\n"
	"uniform LightModelParameters LightModel; \n"
	"\n"
	"uniform bool LightEnabled[MaxLights]; \n"
	"uniform bool LightingEnabled; \n"
	"\n"
	"struct LightModelProducts \n"
	"{ \n"
	"    vec4 sceneColor; \n"
	"}; \n"
	"\n"
	"uniform LightModelProducts FrontNBackLightModelProduct; \n"
	"\n"
	"struct LightProducts \n"
	"{ \n"
	"    vec4 ambient; \n"
	"    vec4 diffuse; \n"
	"    vec4 specular; \n"
	"}; \n"
	"\n"
	"uniform LightProducts FrontNBackLightProduct[MaxLights]; \n"
	"\n"
	"uniform int numLightUsed; \n"
	"\n"
	"\n"
	"\n"
	"#endif \n"
	"\n"
	"// \n"
	"//============================= \n"
	"// texturing \n"
	"\n"
	"#if ((_texMode0 != 0) || (_texMode1 != 0)) \n"
	"uniform mat4 TextureMatrix[2];     \n"
	"#endif \n"
	"\n"
	"#if (_texMode0 != 0) \n"
	"\n"
	"attribute vec4 MultiTexCoord0; \n"
	"varying vec4 TexCoord0; \n"
	"#endif \n"
	"\n"
	"// this is temorary fix for multi texture after compiler bug fix for array we can revert it back (Sandeep Nanda) \n"
	"//varying vec4 TexCoord[MaxTextureCoords]; \n"
	"\n"
	"#if(_texMode1 != 0)    \n"
	"attribute vec4 MultiTexCoord1; \n"
	"varying vec4 TexCoord1; \n"
	"#endif \n"
	"//============================= \n"
	"// miscellaneous \n"
	"\n"
	"uniform bool MultiSampleEnabled; \n"
	"\n"
	"// \n"
	"// functions \n"
	"// \n"
	"#if  _lightEnabled   \n"
	"vec4 lit(float NdotL, float NdotH, float m); \n"
	"\n"
	"\n"
	"vec4 light_point_view_local( \n"
	"vec3 epos, // the eye space vertex position \n"
	"vec3 normal, // the vertex normal \n"
	"int idx ); \n"
	"\n"
	"vec4 light_directional_view_local( \n"
	"vec3 epos,         //the eye space vertex position \n"
	"vec3 normal,         //the vertex normal \n"
	"int idx )  ; \n"
	"#endif \n"
	"\n"
	"void main(void) \n"
	"{ \n"
	"    vec4 epos = vec4(0.0, 0.0, 0.0, 0.0); \n"
	"    vec3 normal; \n"
	"    mat4 palMat; \n"
	"    \n"
	"    // position \n"
	"    #if (_matrixPaletteEnable == 0) \n"
	"    { \n"
	"        \n"
	"        gl_Position = ModelViewProjectionMatrix * Vertex;    \n"
	"        \n"
	"        //#if((_lightEnabled !=0 ) || (_fogMode != 0) || (_pointEnabled != 0)) \n"
	"        epos = ModelViewMatrix * Vertex; // The eye-space vertex position   \n"
	"        //#endif \n"
	"        \n"
	"        normal = normalize(NormalMatrix * Normal); \n"
	"        \n"
	"    } \n"
	"    #elif (_matrixPaletteEnable == 1) \n"
	"    { \n"
	"        vec4 position = vec4(0.0, 0.0, 0.0, 0.0); \n"
	"        vec3 tnormal = vec3(0.0, 0.0, 0.0); \n"
	"        \n"
	"        if (noOfVertexUnit >0.0) \n"
	"        { \n"
	"            position  = Weights.x * (paletteMatrices[int(MatrixIndices.x)] * Vertex); \n"
	"            tnormal = Weights.x * (paletteNormalMatrices[int(MatrixIndices.x)] * Normal); \n"
	"        } \n"
	"        if (noOfVertexUnit > 1.0)    \n"
	"        { \n"
	"            position += Weights.y * (paletteMatrices[int(MatrixIndices.y)] * Vertex); \n"
	"            tnormal += Weights.y * (paletteNormalMatrices[int(MatrixIndices.y)] * Normal); \n"
	"        } \n"
	"        if (noOfVertexUnit > 2.0) \n"
	"        { \n"
	"            position += Weights.z * (paletteMatrices[int(MatrixIndices.z)] * Vertex); \n"
	"            tnormal += Weights.z * (paletteNormalMatrices[int(MatrixIndices.z)] * Normal); \n"
	"        } \n"
	"        if (noOfVertexUnit > 3.0) \n"
	"        { \n"
	"            position += Weights.w * (paletteMatrices[int(MatrixIndices.w)] * Vertex); \n"
	"            tnormal += Weights.w * (paletteNormalMatrices[int(MatrixIndices.w)] * Normal); \n"
	"        } \n"
	"        \n"
	"        // The eye-space vertex position              \n"
	"        epos = position; \n"
	"        \n"
	"        // In matrix palette case, resultant position is in eye space coordinate \n"
	"        // So ModelViewProjectionMatrix will contain projection matrix. \n"
	"        gl_Position = ModelViewProjectionMatrix * position; \n"
	"        \n"
	"        normal = normalize (tnormal); \n"
	"    } \n"
	"    #endif \n"
	"    \n"
	"    FrontColor = Color;   \n"
	"    \n"
	"    #if (_texMode0 != 0) \n"
	"    TexCoord0 = TextureMatrix[0]*MultiTexCoord0; // Temporary Fix for Multitexture (Sandeep Nanda) \n"
	"    #endif \n"
	"    \n"
	"    #if(_texMode1 != 0)     \n"
	"    TexCoord1 = TextureMatrix[1]*MultiTexCoord1;// Temporary Fix for Multitexture (Sandeep Nanda) \n"
	"    #endif \n"
	"    \n"
	"    //User Defined Clip plane enabled \n"
	"    #if (_userClip == 1) \n"
	"    \n"
	"    if (ClipPlaneEnabled[0]) \n"
	"    { \n"
	"        PlanePointDOT[0] = dot(epos, ClipPlane[0]); \n"
	"    } \n"
	"    \n"
	"    if (ClipPlaneEnabled[1]) \n"
	"    { \n"
	"        PlanePointDOT[1] = dot(epos, ClipPlane[1]); \n"
	"    } \n"
	"    \n"
	"    if (ClipPlaneEnabled[2]) \n"
	"    { \n"
	"        PlanePointDOT[2] = dot(epos, ClipPlane[2]); \n"
	"    } \n"
	"    \n"
	"    if (ClipPlaneEnabled[3]) \n"
	"    { \n"
	"        PlanePointDOT[3] = dot(epos, ClipPlane[3]); \n"
	"    } \n"
	"    \n"
	"    if (ClipPlaneEnabled[4]) \n"
	"    { \n"
	"        PlanePointDOT[4] = dot(epos, ClipPlane[4]); \n"
	"    } \n"
	"    \n"
	"    if (ClipPlaneEnabled[5]) \n"
	"    { \n"
	"        PlanePointDOT[5] = dot(epos, ClipPlane[5]); \n"
	"    } \n"
	"    \n"
	"    #endif \n"
	"    \n"
	"    // \n"
	"    //================================== \n"
	"    // lighting \n"
	"    \n"
	"    #if  _lightEnabled  \n"
	"    \n"
	"    \n"
	"    currentMaterial.specular = FrontNBackMaterial.specular; \n"
	"    currentMaterial.shininess = FrontNBackMaterial.shininess; \n"
	"    \n"
	"    if (colorMaterialEnabled) \n"
	"    { \n"
	"        // If color material is enabled then update the material ambient and diffuse color to \n"
	"        // current color(generic vertex color or vertex color pointer) \n"
	"        currentMaterial.ambient = FrontColor; \n"
	"        currentMaterial.diffuse = FrontColor; \n"
	"    } \n"
	"    else \n"
	"    { \n"
	"        currentMaterial.ambient = FrontNBackMaterial.ambient; \n"
	"        currentMaterial.diffuse = FrontNBackMaterial.diffuse; \n"
	"        \n"
	"    } \n"
	"    \n"
	"    int i; \n"
	"    \n"
	"    vec4 vcolor =FrontNBackLightModelProduct.sceneColor; // emission_material + ambient_light * ambient_material              \n"
	"    \n"
	"    for(i=0; i <  numLightUsed ; i++) \n"
	"    { \n"
	"        //directional light                           \n"
	"        if(LightSource[i].isDirectional) \n"
	"        vcolor += light_directional_view_local(epos.xyz/epos.w, normal, i);                                 \n"
	"        else // point light \n"
	"        vcolor += light_point_view_local(epos.xyz, normal, i); \n"
	"        \n"
	"    } \n"
	"    \n"
	"    FrontColor = vcolor ; \n"
	"    FrontColor.a = currentMaterial.diffuse.a; \n"
	"    \n"
	"    #endif \n"
	"    FrontColor =  clamp(FrontColor, 0.0, 1.0); \n"
	"    \n"
	"    // \n"
	"    //================================== \n"
	"    // Point Size Enabled     \n"
	"    #if _pointEnabled \n"
	"    \n"
	"    gl_PointSize =  PointSize;  \n"
	"    \n"
	"    #endif \n"
	"    \n"
	"    \n"
	"    //================================== \n"
	"    // fog \n"
	"    \n"
	"    #if ((_fogMode == 2) ||(_fogMode == 3)) \n"
	"    FogFragCoord = abs(epos.z);   \n"
	"    # endif \n"
	"    \n"
	"    #if ( _fogMode == 1) \n"
	"    { \n"
	"        float eyePos = abs(epos.z); \n"
	"        // f= (end - z) * (end - start) \n"
	"        fogLinear = (Fog.end - eyePos) * Fog.scale; \n"
	"    }         \n"
	"    #endif         \n"
	"    \n"
	"} \n"
	"\n"
	"#if _lightEnabled \n"
	"// point light and local viewer \n"
	"vec4 light_point_view_local( \n"
	"vec3 epos, // the eye space vertex position \n"
	"vec3 normal, // the vertex normal \n"
	"int idx ) \n"
	"{ \n"
	"    //LightSourceParameters light = LightSource[idx]; \n"
	"    \n"
	"    // vector from vertex to the light \n"
	"    vec3 vert2light = LightSource[idx].position.xyz - epos; //changed \n"
	"    \n"
	"    // light direction \n"
	"    vec3 ldir = normalize(vert2light);            \n"
	"    \n"
	"    // distance between the two, need this for attenuation \n"
	"    float d = length(vert2light);          \n"
	"    \n"
	"    //view direction, redundent for multiple lights \n"
	"    \n"
	"    vec3 vdir = vec3(0.0,0.0,1.0); \n"
	"    \n"
	"    //vec3 eye = vec3(0.0,0.0,0.0);      \n"
	"    \n"
	"    //halfway vector \n"
	"    vec3 halfv =  normalize(ldir + vdir);  \n"
	"    \n"
	"    // Compute the diffuse and specular coefficients \n"
	"    //  the diffuse cosine is in coeffs.y, the specular is in coeffs.z \n"
	"    \n"
	"    vec4 coeffs = lit(dot(normal,ldir), dot(normal,halfv), FrontNBackMaterial.shininess); \n"
	"    \n"
	"    /////////////////////////////////////////////////////////////////////////////////// \n"
	"    float spotEffect ; \n"
	"    float NdotL = max(dot(normal,ldir),0.0); \n"
	"    \n"
	"    float spotDot = dot(-ldir, LightSource[idx].spotDirection); \n"
	"    \n"
	"    if(LightSource[idx].spotCutoff >= 180.00) \n"
	"    spotEffect = 1.0; \n"
	"    else if (spotDot < LightSource[idx].spotCosCutoff) \n"
	"    spotEffect = 0.0; // light adds no contribution \n"
	"    else \n"
	"    spotEffect = pow(spotDot, LightSource[idx].spotExponent); \n"
	"    \n"
	"    ////////////////////////////////////////////////////////////////////////////////// \n"
	"    \n"
	"    // Compute the standard shading model \n"
	"    float att = 1.0/(LightSource[idx].constantAttenuation  \n"
	"    + d*LightSource[idx].linearAttenuation + d*d*LightSource[idx].quadraticAttenuation); \n"
	"    vec4 outCol = att* spotEffect *  //attenuation term \n"
	"    (LightSource[idx].ambient*currentMaterial.ambient +                       //ambient term \n"
	"    LightSource[idx].diffuse*currentMaterial.diffuse*coeffs.y +            //diffuse term \n"
	"    LightSource[idx].specular*currentMaterial.specular*coeffs.z);            //specular term \n"
	"    \n"
	"    \n"
	"    return outCol; \n"
	"} \n"
	"\n"
	"// directional light and local viewer \n"
	"vec4 light_directional_view_local( \n"
	"vec3 epos,         //the eye space vertex position \n"
	"vec3 normal,         //the vertex normal \n"
	"int idx )     \n"
	"{ \n"
	"    //LightSourceParameters light = LightSource[idx]; \n"
	"    //vec3 vdir = normalize(-epos); //changed \n"
	"    \n"
	"    vec3 lightDir = normalize(LightSource[idx].position.xyz); \n"
	"    vec3 vdir = vec3(0.0,0.0,1.0);     \n"
	"    vec3 halfv = normalize(lightDir + vdir); \n"
	"    \n"
	"    \n"
	"    vec4 coeffs = lit(dot(normal, lightDir), dot(normal,halfv),FrontNBackMaterial.shininess); \n"
	"    \n"
	"    // Compute the standard shading model \n"
	"    vec4 outCol = LightSource[idx].ambient*currentMaterial.ambient +               //ambient term \n"
	"    LightSource[idx].diffuse* currentMaterial.diffuse*coeffs.y  +      //diffuse term \n"
	"    LightSource[idx].specular*currentMaterial.specular*coeffs.z ;            //specular term \n"
	"    \n"
	"    return outCol; \n"
	"} \n"
	"\n"
	"vec4 lit(float NdotL, float NdotH, float m) \n"
	"{ \n"
	"    vec4 coeff; \n"
	"    // ambient coefficient, which is always 1.0 \n"
	"    coeff.x = 1.0; \n"
	"    \n"
	"    // diffuse coefficient \n"
	"    if(NdotL < 0.0) coeff.y = 0.0; \n"
	"    else coeff.y = NdotL; \n"
	"    \n"
	"    //specular coefficient \n"
	"    if(NdotL <= 0.0 || NdotH < 0.0)  \n"
	"    coeff.z = 0.0; \n"
	"    else  \n"
	"    coeff.z = pow(NdotH, m); \n"
	"    \n"
	"    coeff.w = 1.0; \n"
	"    \n"
	"    return coeff; \n"
	"} \n"
	"#endif \n"
	"";

#ifdef GL_HELPERS_INCLUDED
//glHelpers.h must be included BEFORE any of the shader header files. Also make sure you have the latest version of glHelpers.h
static ghShader n6VertShader(n6VertText, n6Vert, n6VertLength, n6VertCheckSum);


#endif


#endif //_n6Vert_h_
