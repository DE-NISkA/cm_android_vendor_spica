#ifndef _n5Frag_h_
#define _n5Frag_h_


// Header generated from binary by WriteAsBinHeader()..
static const int n5FragLength = 272;
static const unsigned int n5Frag[n5FragLength]={
	0x20205350,	0xFFFF0008,	0x00000048,	0x01020000,	0x00000022,	0x0000000A,	0x00000000,	0x00000000,	0x00000003,	0x00000000,
	0x00000002,	0x00000002,	0x00000000,	0x00000000,	0x00000002,	0x00000000,	0x00000074,	0x00000000,	0x18000000,	0x0718FF07,
	0x230820FF,	0x00000000,	0x09FF0709,	0x0718FF07,	0x0EF82205,	0x00000000,	0x02000000,	0x01024402,	0x037822E4,	0x00000000,
	0x00000000,	0x81020000,	0x114022E4,	0x00000000,	0x00000000,	0x01020001,	0x034022FF,	0x00000000,	0x00000000,	0x01020000,
	0x074022FF,	0x00000000,	0x00000000,	0x00010000,	0x00B822A4,	0x00000000,	0x00000000,	0x0102E407,	0x107822E4,	0x00000000,
	0x00000000,	0x01020000,	0x00F821E4,	0x00000000,	0x00000000,	0x02010000,	0x00882000,	0x00000000,	0x03000000,	0x01000002,
	0x0C086100,	0x00000000,	0x00000000,	0x06010000,	0x18800200,	0x00000000,	0x00000000,	0x00000000,	0x00B821A4,	0x00000000,
	0x00000000,	0x00000000,	0x18000400,	0x00000000,	0x00000000,	0x02010000,	0x00882000,	0x00000000,	0x05000000,	0x01000002,
	0x0C086100,	0x00000000,	0x00000000,	0x06010000,	0x18800100,	0x00000000,	0x00000000,	0x00000000,	0x00C021FF,	0x00000000,
	0x00000000,	0x01010000,	0x00F820E4,	0x00000000,	0x18000000,	0x0718FF07,	0x230822FF,	0x00000000,	0x0AFF070A,	0x0718FF07,
	0x0EF82305,	0x00000000,	0x07000000,	0x01034402,	0x037823E4,	0x00000000,	0x00000000,	0x81030000,	0x114023E4,	0x00000000,
	0x02000000,	0x01030001,	0x034023FF,	0x00000000,	0x00000000,	0x01030000,	0x074023FF,	0x00000000,	0x00000000,	0x00020000,
	0x00B823A4,	0x00000000,	0x01000000,	0x0103E407,	0x107823E4,	0x00000000,	0x00000000,	0x01030000,	0x00F821E4,	0x00000000,
	0x00000000,	0x02010000,	0x00882200,	0x00000000,	0x04000000,	0x01020002,	0x0C086100,	0x00000000,	0x00000000,	0x06010000,
	0x18800100,	0x00000000,	0x00000000,	0x02090000,	0x00B821A4,	0x00000000,	0x01000000,	0x0100E401,	0x037A10E4,	0x00000000,
	0x00000000,	0x00000000,	0x1E000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x3F800000,	0x3F800000,
	0x3F800000,	0x3F800000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,
	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,
	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x00000000,	0x3F800000,	0x00000000,	0x00000000,	0x00000000,
	0x3F800000,	0x3F800000,	0x3F800000,	0x00000000,	0x00000010,	0x0000000A,	0x00000009,	0x00000000,	0x00000000,	0x00000026,
	0x00000009,	0x00000009,	0x00000000,	0x00000004,	0x0000003B,	0x00000009,	0x00000009,	0x00000000,	0x00000008,	0x00000000,
	0x00000007,	0x00000003,	0x00020001,	0x00000008,	0x00000008,	0x00000007,	0x00000003,	0x00020001,	0x0000001C,	0x0000001B,
	0x0000000A,	0x0000000F,	0x00030005,	0x00000000,	0x00000030,	0x0000000A,	0x0000000F,	0x00030005,	0x00000004,	0x00000045,
	0x00000012,	0x00000002,	0x00020001,	0x0000000C,	0x00000002,	0x00000004,	0x00000058,	0x0000001B,	0x00000002,	0x00020001,
	0x00000014,	0x00000002,	0x00000004,	0x44786554,	0x00306D69,	0x44786554,	0x00316D69,	0x6E6F7246,	0x6C6F4374,	0x5400726F,
	0x6D497865,	0x73656761,	0x65540030,	0x6F6F4378,	0x00306472,	0x49786554,	0x6567616D,	0x54003173,	0x6F437865,	0x3164726F,
	0x706C6100,	0x65546168,	0x72757478,	0x616E4565,	0x00656C62,	0x6C416F6E,	0x43616870,	0x6E6E6168,	0x65546C65,	0x72757478,
	0x616E4565,	0x00656C62,};

//checksum generated by simpleCheckSum()
static const unsigned int n5FragCheckSum = 72;

static const char* n5FragText = 
	"#define _isMipmap1             1 \n"
	"#define _isMipmap0             1 \n"
	"#define _fogMode               0 \n"
	"#define _texMode1              2 \n"
	"#define _texMode0              1 \n"
	"#define _pointSprite1          0 \n"
	"#define _pointSprite0          0 \n"
	"#define _matrixPaletteEnable   0 \n"
	"#define _userClip              0 \n"
	"#define _lightEnabled          0 \n"
	"#define _pointEnabled          0 \n"
	"\n"
	"\n"
	"#ifdef GL_ES \n"
	"precision highp float; \n"
	"#endif \n"
	"\n"
	"#extension SAM_FRAG_EXPLICIT_TEX_LOD : require \n"
	"\n"
	"// user-defined clipping \n"
	"#if (_userClip == 1) \n"
	"const int MaxClipPlanes =6; \n"
	"uniform bool ClipPlaneEnabled[MaxClipPlanes]; \n"
	"varying float PlanePointDOT[MaxClipPlanes]; \n"
	"#endif \n"
	"\n"
	"varying vec4 FrontColor; \n"
	"\n"
	"\n"
	"\n"
	"\n"
	"//================================= \n"
	"// fog \n"
	"\n"
	"#if ((_fogMode == 2) || (_fogMode == 3)) \n"
	"\n"
	"#define FOGMODE_LINEAR 1 \n"
	"#define FOGMODE_EXP 2 \n"
	"#define FOGMODE_EXP2 3 \n"
	"\n"
	"#define LOG2E 1.442695 // 1 / log(2) \n"
	"varying float FogFragCoord; \n"
	"struct FogParameters \n"
	"{ \n"
	"    float density; \n"
	"    float start; \n"
	"    float end; \n"
	"    vec4 color; \n"
	"    float scale; // Derived: 1.0 / (end - start) \n"
	"    int mode; \n"
	"}; \n"
	"\n"
	"uniform FogParameters Fog; \n"
	"uniform bool FogEnabled; \n"
	"#endif \n"
	"\n"
	"#if (_fogMode == 1) \n"
	"varying float fogLinear; \n"
	"struct FogParameters \n"
	"{ \n"
	"    float density; \n"
	"    float start; \n"
	"    float end; \n"
	"    vec4 color; \n"
	"    float scale;  \n"
	"    int mode; \n"
	"}; \n"
	"\n"
	"uniform FogParameters Fog; \n"
	"\n"
	"#endif     \n"
	"\n"
	"\n"
	"//================================= \n"
	"// texturing \n"
	"#if ((_texMode0 != 0) || (_texMode1 != 0)) \n"
	"const int MaxTextureImageUnits = 2; \n"
	"#endif \n"
	"\n"
	"\n"
	"#if (_texMode0 != 0) \n"
	"uniform sampler2D TexImages0; \n"
	"varying vec4 TexCoord0; \n"
	"#endif \n"
	"\n"
	"#if(_texMode1 != 0) \n"
	"uniform sampler2D TexImages1; \n"
	"varying vec4 TexCoord1; \n"
	"#endif \n"
	"\n"
	"\n"
	"\n"
	"//================================= \n"
	"// texture environment \n"
	"\n"
	"#if ((_texMode0 == 6) || (_texMode1 == 6) ||(_texMode0 == 5) || (_texMode1 == 5)) \n"
	"\n"
	"#define TEX_ENV_MODE_REPLACE    1 \n"
	"#define TEX_ENV_MODE_MODULATE   2 \n"
	"#define TEX_ENV_MODE_ADD        3 \n"
	"#define TEX_ENV_MODE_DECAL        4 \n"
	"#define TEX_ENV_MODE_BLEND        5 \n"
	"#define TEX_ENV_MODE_COMBINE    6 \n"
	"\n"
	"// combine RGB \n"
	"#define TEX_COMBINE_RGB_REPLACE        1 \n"
	"#define TEX_COMBINE_RGB_MODULATE    2 \n"
	"#define TEX_COMBINE_RGB_ADD            3 \n"
	"#define TEX_COMBINE_RGB_ADD_SIGNED    4 \n"
	"#define TEX_COMBINE_RGB_INTERPOLATE    5 \n"
	"#define TEX_COMBINE_RGB_SUBTRACT    6 \n"
	"#define TEX_COMBINE_RGB_DOT3_RGB    7 \n"
	"#define TEX_COMBINE_RGB_DOT3_RGBA    8 \n"
	"\n"
	"// combine alpha \n"
	"#define TEX_COMBINE_ALPHA_REPLACE        1 \n"
	"#define TEX_COMBINE_ALPHA_MODULATE        2 \n"
	"#define TEX_COMBINE_ALPHA_ADD            3 \n"
	"#define TEX_COMBINE_ALPHA_ADD_SIGNED    4 \n"
	"#define TEX_COMBINE_ALPHA_INTERPOLATE    5 \n"
	"#define TEX_COMBINE_ALPHA_SUBTRACT        6 \n"
	"\n"
	"// Combiner RGB and ALPHA source arguments \n"
	"#define TEX_ENV_COMBINER_SRC_TEXTURE        1 \n"
	"#define TEX_ENV_COMBINER_SRC_CONSTANT        2 \n"
	"#define TEX_ENV_COMBINER_SRC_PRIMARY_COLOR    3 \n"
	"#define TEX_ENV_COMBINER_SRC_PREVIOUS        4 \n"
	"\n"
	"// \n"
	"// Combiner RGB operands \n"
	"// \n"
	"#define TEX_ENV_COMBINER_RGB_OP_SRC_COLOR            1 \n"
	"#define TEX_ENV_COMBINER_RGB_OP_ONE_MINUS_SRC_COLOR    2 \n"
	"#define TEX_ENV_COMBINER_RGB_OP_SRC_ALPHA            3 \n"
	"#define TEX_ENV_COMBINER_RGB_OP_ONE_MINUS_SRC_ALPHA    4 \n"
	"\n"
	"// \n"
	"// Combiner ALPHA operands \n"
	"// \n"
	"#define TEX_ENV_COMBINER_ALPHA_OP_SRC_ALPHA                1 \n"
	"#define TEX_ENV_COMBINER_ALPHA_OP_ONE_MINUS_SRC_ALPHA    2 \n"
	"\n"
	"\n"
	"\n"
	"struct _TexEnv \n"
	"{ \n"
	"    vec4 color; \n"
	"    int mode; \n"
	"    \n"
	"    int combineRgb; \n"
	"    int combineAlpha; \n"
	"    \n"
	"    int srcRgb[3]; \n"
	"    int srcAlpha[3]; \n"
	"    \n"
	"    int operandRgb[3]; \n"
	"    int operandAlpha[3]; \n"
	"    \n"
	"    float rgbScale; \n"
	"    float alphaScale; \n"
	"}; \n"
	"\n"
	"uniform _TexEnv TexEnv[MaxTextureImageUnits]; \n"
	"\n"
	"#endif \n"
	"\n"
	"#if ((_texMode0 != 0) || (_texMode1 != 0)) \n"
	"//Fixes for GL_ALPHA texture bug  \n"
	"uniform bool alphaTextureEnable[MaxTextureImageUnits]; \n"
	"//Fixes for GL_LUMINANCE and GL_RGB texture bug \n"
	"uniform bool noAlphaChannelTextureEnable[MaxTextureImageUnits]; \n"
	"#endif \n"
	"\n"
	"#if ((_texMode0 == 6) || (_texMode1 == 6))  \n"
	"\n"
	"vec4 tex_env_combiner(vec4 fragColor, vec4 prevColor, vec4 srcColor, int nth); \n"
	"\n"
	"vec4 tex_arg_calculation(vec4 fragColor, vec4 prevColor, vec4 srcColor, vec4 EnvColor, int srcrgb, int opndrgb, int srcAlpha, int operandAlpha); \n"
	"vec4 tex_arg_calculation(vec4 fragColor, vec4 prevColor, vec4 srcColor, vec4 EnvColor, int srcrgb, int opndrgb, int srcAlpha, int operandAlpha) \n"
	"{ \n"
	"    vec4 temp; \n"
	"    if((srcrgb) == TEX_ENV_COMBINER_SRC_TEXTURE) \n"
	"    { \n"
	"        if((opndrgb) == TEX_ENV_COMBINER_RGB_OP_SRC_COLOR) \n"
	"        temp.rgb = srcColor.rgb; \n"
	"        else if((opndrgb) == TEX_ENV_COMBINER_RGB_OP_ONE_MINUS_SRC_COLOR) \n"
	"        temp.rgb = 1.0 - srcColor.rgb; \n"
	"        else if((opndrgb) == TEX_ENV_COMBINER_RGB_OP_SRC_ALPHA) \n"
	"        temp.rgb = vec3(srcColor.a); \n"
	"        else //if((opndrgb) == TEX_ENV_COMBINER_RGB_OP_ONE_MINUS_SRC_ALPHA) \n"
	"        temp.rgb = vec3(1.0 - srcColor.a); \n"
	"    } \n"
	"    else if((srcrgb) == TEX_ENV_COMBINER_SRC_CONSTANT) \n"
	"    { \n"
	"        if((opndrgb) == TEX_ENV_COMBINER_RGB_OP_SRC_COLOR) \n"
	"        temp.rgb = EnvColor.rgb; \n"
	"        else if((opndrgb) == TEX_ENV_COMBINER_RGB_OP_ONE_MINUS_SRC_COLOR) \n"
	"        temp.rgb = 1.0 - EnvColor.rgb; \n"
	"        else if((opndrgb) == TEX_ENV_COMBINER_RGB_OP_SRC_ALPHA) \n"
	"        temp.rgb = vec3(EnvColor.a); \n"
	"        else //if((opndrgb) == TEX_ENV_COMBINER_RGB_OP_ONE_MINUS_SRC_ALPHA) \n"
	"        temp.rgb = vec3(1.0 - EnvColor.a); \n"
	"    } \n"
	"    else if((srcrgb) == TEX_ENV_COMBINER_SRC_PRIMARY_COLOR) \n"
	"    { \n"
	"        if((opndrgb) == TEX_ENV_COMBINER_RGB_OP_SRC_COLOR) \n"
	"        temp.rgb = fragColor.rgb; \n"
	"        else if((opndrgb) == TEX_ENV_COMBINER_RGB_OP_ONE_MINUS_SRC_COLOR) \n"
	"        temp.rgb = 1.0 - fragColor.rgb; \n"
	"        else if((opndrgb) == TEX_ENV_COMBINER_RGB_OP_SRC_ALPHA) \n"
	"        temp.rgb = vec3(fragColor.a); \n"
	"        else //if((opndrgb) == TEX_ENV_COMBINER_RGB_OP_ONE_MINUS_SRC_ALPHA) \n"
	"        temp.rgb = vec3(1.0 - fragColor.a); \n"
	"    } \n"
	"    else //if((srcrgb) == TEX_ENV_COMBINER_SRC_PREVIOUS) \n"
	"    { \n"
	"        if((opndrgb) == TEX_ENV_COMBINER_RGB_OP_SRC_COLOR) \n"
	"        temp.rgb = prevColor.rgb; \n"
	"        else if((opndrgb) == TEX_ENV_COMBINER_RGB_OP_ONE_MINUS_SRC_COLOR) \n"
	"        temp.rgb = 1.0 - prevColor.rgb; \n"
	"        else if((opndrgb) == TEX_ENV_COMBINER_RGB_OP_SRC_ALPHA) \n"
	"        temp.rgb = vec3(prevColor.a); \n"
	"        else //if((opndrgb) == TEX_ENV_COMBINER_RGB_OP_ONE_MINUS_SRC_ALPHA) \n"
	"        temp.rgb = vec3(1.0 - prevColor.a); \n"
	"    } \n"
	"    \n"
	"    // \n"
	"    // COMBINE_ALPHA \n"
	"    // \n"
	"    if((srcAlpha) == TEX_ENV_COMBINER_SRC_TEXTURE) \n"
	"    { \n"
	"        if((operandAlpha) == TEX_ENV_COMBINER_ALPHA_OP_SRC_ALPHA) \n"
	"        temp.a = srcColor.a; \n"
	"        else //if((operandAlpha) == TEX_ENV_COMBINER_ALPHA_OP_ONE_MINUS_SRC_ALPHA) \n"
	"        temp.a = 1.0 - srcColor.a; \n"
	"    } \n"
	"    else if((srcAlpha) == TEX_ENV_COMBINER_SRC_CONSTANT) \n"
	"    { \n"
	"        if((operandAlpha) == TEX_ENV_COMBINER_ALPHA_OP_SRC_ALPHA) \n"
	"        temp.a = EnvColor.a; \n"
	"        else //if((operandAlpha) == TEX_ENV_COMBINER_ALPHA_OP_ONE_MINUS_SRC_ALPHA) \n"
	"        temp.a = 1.0 - EnvColor.a; \n"
	"    } \n"
	"    else if((srcAlpha) == TEX_ENV_COMBINER_SRC_PRIMARY_COLOR) \n"
	"    { \n"
	"        if((operandAlpha) == TEX_ENV_COMBINER_ALPHA_OP_SRC_ALPHA) \n"
	"        temp.a = fragColor.a; \n"
	"        else //if((operandAlpha) == TEX_ENV_COMBINER_ALPHA_OP_ONE_MINUS_SRC_ALPHA) \n"
	"        temp.a = 1.0 - fragColor.a; \n"
	"    } \n"
	"    else //if((srcAlpha) == TEX_ENV_COMBINER_SRC_PREVIOUS) \n"
	"    { \n"
	"        if((operandAlpha) == TEX_ENV_COMBINER_ALPHA_OP_SRC_ALPHA) \n"
	"        temp.a = prevColor.a; \n"
	"        else //if((operandAlpha) == TEX_ENV_COMBINER_ALPHA_OP_ONE_MINUS_SRC_ALPHA) \n"
	"        temp.a = 1.0 - prevColor.a; \n"
	"    } \n"
	"    return temp; \n"
	"} \n"
	"vec4 tex_env_combiner(vec4 fragColor, vec4 prevColor, vec4 srcColor, int nth) \n"
	"{ \n"
	"    int i; \n"
	"    vec4 arg[3], c; \n"
	"    //vec4 temp; \n"
	"    int srcrgb, opndrgb,srcAlpha, operandAlpha; \n"
	"    vec4 EnvColor; \n"
	"    float rgbScale, alphaScale; \n"
	"    int combrgb, combalpha; \n"
	"    \n"
	"    if (nth == 0) \n"
	"    { \n"
	"        srcrgb = TexEnv[0].srcRgb[0]; \n"
	"        opndrgb = TexEnv[0].operandRgb[0]; \n"
	"        srcAlpha = TexEnv[0].srcAlpha[0]; \n"
	"        operandAlpha = TexEnv[0].operandAlpha[0]; \n"
	"        EnvColor = TexEnv[0].color; \n"
	"        rgbScale = TexEnv[0].rgbScale; \n"
	"        alphaScale = TexEnv[0].alphaScale; \n"
	"        combrgb = TexEnv[0].combineRgb; \n"
	"        combalpha = TexEnv[0].combineAlpha; \n"
	"    } \n"
	"    else //if (nth == 1) \n"
	"    { \n"
	"        srcrgb = TexEnv[1].srcRgb[0]; \n"
	"        opndrgb = TexEnv[1].operandRgb[0]; \n"
	"        srcAlpha = TexEnv[1].srcAlpha[0]; \n"
	"        operandAlpha = TexEnv[1].operandAlpha[0]; \n"
	"        EnvColor = TexEnv[1].color; \n"
	"        rgbScale = TexEnv[1].rgbScale; \n"
	"        alphaScale = TexEnv[1].alphaScale; \n"
	"        combrgb = TexEnv[1].combineRgb; \n"
	"        combalpha = TexEnv[1].combineAlpha; \n"
	"    } \n"
	"    arg[0] = tex_arg_calculation (fragColor,prevColor,srcColor,EnvColor, srcrgb, opndrgb, srcAlpha, operandAlpha); \n"
	"    \n"
	"    if (nth == 0) \n"
	"    { \n"
	"        srcrgb = TexEnv[0].srcRgb[1]; \n"
	"        opndrgb = TexEnv[0].operandRgb[1]; \n"
	"        srcAlpha = TexEnv[0].srcAlpha[1]; \n"
	"        operandAlpha = TexEnv[0].operandAlpha[1]; \n"
	"    } \n"
	"    else //if (nth == 1) \n"
	"    { \n"
	"        srcrgb = TexEnv[1].srcRgb[1]; \n"
	"        opndrgb = TexEnv[1].operandRgb[1]; \n"
	"        srcAlpha = TexEnv[1].srcAlpha[1]; \n"
	"        operandAlpha = TexEnv[1].operandAlpha[1]; \n"
	"    } \n"
	"    \n"
	"    arg[1] = tex_arg_calculation (fragColor,prevColor,srcColor,EnvColor, srcrgb, opndrgb, srcAlpha, operandAlpha); \n"
	"    \n"
	"    if (nth == 0) \n"
	"    { \n"
	"        srcrgb = TexEnv[0].srcRgb[2]; \n"
	"        opndrgb = TexEnv[0].operandRgb[2]; \n"
	"        srcAlpha = TexEnv[0].srcAlpha[2]; \n"
	"        operandAlpha = TexEnv[0].operandAlpha[2]; \n"
	"    } \n"
	"    else //if (nth == 1) \n"
	"    { \n"
	"        srcrgb = TexEnv[1].srcRgb[2]; \n"
	"        opndrgb = TexEnv[1].operandRgb[2]; \n"
	"        srcAlpha = TexEnv[1].srcAlpha[2]; \n"
	"        operandAlpha = TexEnv[1].operandAlpha[2]; \n"
	"    } \n"
	"    \n"
	"    arg[2] = tex_arg_calculation (fragColor,prevColor,srcColor,EnvColor, srcrgb, opndrgb, srcAlpha, operandAlpha); \n"
	"    \n"
	"    // \n"
	"    // COMBINE \n"
	"    // \n"
	"    \n"
	"    if(combrgb == TEX_COMBINE_RGB_REPLACE) \n"
	"    c.rgb = arg[0].rgb; \n"
	"    else if(combrgb == TEX_COMBINE_RGB_MODULATE) \n"
	"    c.rgb = arg[0].rgb * arg[1].rgb; \n"
	"    else if(combrgb == TEX_COMBINE_RGB_ADD) \n"
	"    c.rgb = arg[0].rgb + arg[1].rgb; \n"
	"    else if(combrgb == TEX_COMBINE_RGB_ADD_SIGNED) \n"
	"    c.rgb = arg[0].rgb + arg[1].rgb - 0.5; \n"
	"    else if(combrgb == TEX_COMBINE_RGB_INTERPOLATE) \n"
	"    c.rgb = mix(arg[1].rgb, arg[0].rgb, arg[2].rgb); \n"
	"    else if(combrgb == TEX_COMBINE_RGB_DOT3_RGB || \n"
	"            combrgb == TEX_COMBINE_RGB_DOT3_RGBA) \n"
	"    { \n"
	"        float d; \n"
	"        \n"
	"        d = 4.0 *((arg[0].r - 0.5)*(arg[1].r - 0.5) + (arg[0].g - 0.5)*(arg[1].g - 0.5) + (arg[0].b - 0.5)*(arg[1].b - 0.5)); \n"
	"        c = vec4(d); \n"
	"    } \n"
	"    else //if(combrgb == TEX_COMBINE_RGB_SUBTRACT) \n"
	"    c.rgb = arg[0].rgb - arg[1].rgb; \n"
	"    \n"
	"    c.rgb = rgbScale * c.rgb; \n"
	"    \n"
	"    if (combrgb != TEX_COMBINE_RGB_DOT3_RGBA) \n"
	"    { \n"
	"        if(combalpha == TEX_COMBINE_ALPHA_REPLACE) \n"
	"        c.a = arg[0].a; \n"
	"        else if(combalpha == TEX_COMBINE_ALPHA_MODULATE) \n"
	"        c.a = arg[0].a * arg[1].a; \n"
	"        else if(combalpha == TEX_COMBINE_ALPHA_ADD) \n"
	"        c.a = arg[0].a + arg[1].a; \n"
	"        else if(combalpha == TEX_COMBINE_ALPHA_ADD_SIGNED) \n"
	"        c.a = arg[0].a + arg[1].a - 0.5; \n"
	"        else if(combalpha == TEX_COMBINE_ALPHA_INTERPOLATE) \n"
	"        c.a = mix(arg[1].a, arg[0].a, arg[2].a); \n"
	"        else //if(combalpha == TEX_COMBINE_ALPHA_SUBTRACT) \n"
	"        c.a = arg[0].a - arg[1].a; \n"
	"    } \n"
	"    \n"
	"    c.a = alphaScale * c.a; \n"
	"    \n"
	"    return c; \n"
	"} \n"
	"\n"
	"#endif  \n"
	"\n"
	"void main( void ) \n"
	"{ \n"
	"    int i; \n"
	"    vec4 fragColor = FrontColor;   \n"
	"    \n"
	"    // According to user defined clip plane discard a fragment \n"
	"    #if (_userClip == 1) \n"
	"    \n"
	"    if(ClipPlaneEnabled[0]) \n"
	"    { \n"
	"        if(PlanePointDOT[0] < 0.0) \n"
	"        discard; \n"
	"    } \n"
	"    \n"
	"    if(ClipPlaneEnabled[1]) \n"
	"    { \n"
	"        if(PlanePointDOT[1] < 0.0) \n"
	"        discard; \n"
	"    } \n"
	"    \n"
	"    if(ClipPlaneEnabled[2]) \n"
	"    { \n"
	"        if(PlanePointDOT[2] < 0.0) \n"
	"        discard; \n"
	"    } \n"
	"    \n"
	"    if(ClipPlaneEnabled[3]) \n"
	"    { \n"
	"        if(PlanePointDOT[3] < 0.0) \n"
	"        discard; \n"
	"    } \n"
	"    \n"
	"    if(ClipPlaneEnabled[4]) \n"
	"    { \n"
	"        if(PlanePointDOT[4] < 0.0) \n"
	"        discard; \n"
	"    } \n"
	"    \n"
	"    if(ClipPlaneEnabled[5]) \n"
	"    { \n"
	"        if(PlanePointDOT[5] < 0.0) \n"
	"        discard; \n"
	"    } \n"
	"    \n"
	"    #endif    \n"
	"    \n"
	"    // texturing \n"
	"    \n"
	"    vec4 prevColor, srcColor; \n"
	"    \n"
	"    prevColor = fragColor; \n"
	"    \n"
	"    #if (_texMode0 != 0) && (_pointSprite0 == 0) && (_isMipmap0 == 1) \n"
	"    srcColor = texture2D(TexImages0, TexCoord0.xy); \n"
	"    #elif (_texMode0 != 0) && (_pointSprite0 == 0) && (_isMipmap0 == 0) \n"
	"    srcColor = texture2DLod(TexImages0, TexCoord0.xy , 0.0); \n"
	"    #elif (_texMode0 != 0) && (_pointSprite0 == 1) && (_isMipmap0 == 1) \n"
	"    srcColor = texture2D(TexImages0, gl_PointCoord); \n"
	"    #elif (_texMode0 != 0) && (_pointSprite0 == 1) && (_isMipmap0 == 0) \n"
	"    srcColor = texture2DLod(TexImages0, gl_PointCoord , 0.0); \n"
	"    #endif \n"
	"    \n"
	"    \n"
	"    #if (_texMode0 == 2) \n"
	"    if(alphaTextureEnable[0]) \n"
	"    srcColor.rgb = vec3(1.0,1.0,1.0); \n"
	"    prevColor *= srcColor; \n"
	"    #elif(_texMode0 == 1)    \n"
	"    if(alphaTextureEnable[0]) \n"
	"    srcColor.rgb = prevColor.rgb; \n"
	"    else if(noAlphaChannelTextureEnable[0]) \n"
	"    srcColor.a = prevColor.a; \n"
	"    prevColor = srcColor; \n"
	"    #elif(_texMode0 == 4) \n"
	"    \n"
	"    prevColor = vec4(mix(prevColor.rgb, srcColor.rgb, srcColor.a), prevColor.a) ; \n"
	"    prevColor = clamp(prevColor, 0.0, 1.0);  \n"
	"    #elif(_texMode0 == 5) \n"
	"    \n"
	"    prevColor = vec4(mix(prevColor.rgb, TexEnv[0].color.rgb, srcColor.rgb), prevColor.a * srcColor.a) ; \n"
	"    prevColor = clamp(prevColor, 0.0, 1.0);   \n"
	"    #elif(_texMode0 == 3)   \n"
	"    \n"
	"    prevColor = clamp(vec4(prevColor.rgb + srcColor.rgb, prevColor.a * srcColor.a),0.0,1.0); \n"
	"    #elif(_texMode0 == 6) \n"
	"    prevColor = tex_env_combiner(fragColor, prevColor, srcColor, 0); \n"
	"    prevColor = clamp(prevColor, 0.0, 1.0); \n"
	"    #endif \n"
	"    \n"
	"    \n"
	"    #if (_texMode1 != 0) && (_pointSprite1 == 0) && (_isMipmap1 == 1) \n"
	"    srcColor = texture2D(TexImages1, TexCoord1.xy); \n"
	"    #elif (_texMode1 != 0) && (_pointSprite1 == 0) && (_isMipmap1 == 0) \n"
	"    srcColor = texture2DLod(TexImages1, TexCoord1.xy , 0.0); \n"
	"    #elif (_texMode1 != 0) && (_pointSprite1 == 1) && (_isMipmap1 == 1) \n"
	"    srcColor = texture2D(TexImages1, gl_PointCoord); \n"
	"    #elif (_texMode1 != 0) && (_pointSprite1 == 1) && (_isMipmap1 == 0) \n"
	"    srcColor = texture2DLod(TexImages1, gl_PointCoord , 0.0); \n"
	"    #endif \n"
	"    \n"
	"    #if(_texMode1 == 2)   \n"
	"    if(alphaTextureEnable[1]) \n"
	"    srcColor.rgb = vec3(1.0,1.0,1.0); \n"
	"    prevColor *= srcColor; \n"
	"    #elif(_texMode1 == 1)   \n"
	"    if(alphaTextureEnable[1]) \n"
	"    srcColor.rgb = prevColor.rgb; \n"
	"    else if(noAlphaChannelTextureEnable[1]) \n"
	"    srcColor.a = prevColor.a; \n"
	"    prevColor = srcColor; \n"
	"    #elif(_texMode1 == 4)   \n"
	"    \n"
	"    prevColor =vec4(mix(prevColor.rgb, srcColor.rgb, srcColor.a), prevColor.a) ; \n"
	"    prevColor = clamp(prevColor, 0.0, 1.0);  \n"
	"    #elif(_texMode1 == 5)   \n"
	"    \n"
	"    prevColor = vec4(mix(prevColor.rgb, TexEnv[0].color.rgb, srcColor.rgb), prevColor.a * srcColor.a) ; \n"
	"    prevColor = clamp(prevColor, 0.0, 1.0); \n"
	"    #elif(_texMode1 == 3)   \n"
	"    \n"
	"    prevColor = clamp(vec4(prevColor.rgb + srcColor.rgb, prevColor.a * srcColor.a),0.0,1.0); \n"
	"    #elif(_texMode1 == 6)   \n"
	"    \n"
	"    prevColor = tex_env_combiner(fragColor, prevColor, srcColor, 1); \n"
	"    prevColor = clamp(prevColor, 0.0, 1.0); \n"
	"    #endif \n"
	"    \n"
	"    fragColor = prevColor; \n"
	"    \n"
	"    \n"
	"    \n"
	"    //========================================= \n"
	"    // fog \n"
	"    \n"
	"    #if (_fogMode == 1) \n"
	"    { \n"
	"        float fog ; \n"
	"        fog = clamp(fogLinear, 0.0 ,1.0); \n"
	"        // f= (end - z) * (end - start) \n"
	"        fragColor.rgb = mix(Fog.color.rgb, fragColor.rgb, fog);     \n"
	"    } \n"
	"    #elif (_fogMode == 2) \n"
	"    { \n"
	"        // f = e^(-density * z) \n"
	"        float fog; \n"
	"        fog = clamp(exp2(-Fog.density * FogFragCoord * LOG2E), 0.0, 1.0); \n"
	"        fragColor.rgb = mix(Fog.color.rgb, fragColor.rgb, fog);     \n"
	"    } \n"
	"    #elif (_fogMode == 3) \n"
	"    { \n"
	"        // f = e^(-(density * z)^2) \n"
	"        float fog; \n"
	"        fog = clamp(exp2(-Fog.density * Fog.density * FogFragCoord * FogFragCoord * LOG2E), 0.0, 1.0); \n"
	"        fragColor.rgb = mix(Fog.color.rgb, fragColor.rgb, fog);     \n"
	"    } \n"
	"    #endif \n"
	"    \n"
	"    //========================================= \n"
	"    gl_FragColor = fragColor; \n"
	"} ";

#ifdef GL_HELPERS_INCLUDED
//glHelpers.h must be included BEFORE any of the shader header files. Also make sure you have the latest version of glHelpers.h
static ghShader n5FragShader(n5FragText, n5Frag, n5FragLength, n5FragCheckSum);


#endif


#endif //_n5Frag_h_
